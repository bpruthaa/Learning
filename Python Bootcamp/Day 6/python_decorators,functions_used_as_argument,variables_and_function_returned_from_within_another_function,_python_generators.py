# -*- coding: utf-8 -*-
"""Python Decorators,Functions Used as Argument,Variables and Function Returned  from Within Another Function, Python Generators.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1yilMC1K8LKZi6bIHHmaAj4KR-f_CskYr

#Python Decorators
Functions which modify the functionality of other functions without modifying its structure
Can Be Initialized in following 2 ways:
"""

'''@decname
def func():
  print("Statement")


  OR

def func():
  print("Statement")

func=decName(func)'''

"""# Function As Object"""

def welcome(a):
  print("Hello {0}, Welcome to Python Bootcamp!!".format(a))

welcome("Champ")

a =  welcome   #No Parenthesis. If it is Parenthesis, it will call Function. Function as Object
a("champ")

"""#Function As Variable"""

def lowerCase(text):
  return text.lower()
def upperCase(text):
  return text.upper()
def a(welcome):
  message=welcome("Hello all welcome to Python Bootcamp") #Function as Variable
  print(message)

a(lowerCase)
a(upperCase)

"""#Returning Function From Another Function"""

def addMain(a):
  def subMain(b):
    print(a,b)
    return a+b
  return subMain

addition = addMain(100)
print(addition(75))

"""# DECORATORS in Action"""

def decoratorFunc (welcome):  #2 Decorator Function
  def a():#3 Can Access outer Local functions like "welcome"
    print("Start")
    welcome()#4 Calling Actual Function
    print("End")
  return a
def subFunc():
  print("Sub Func")

subFunc = decoratorFunc(subFunc)#1 SubFUnction inside Decorator Function to control Behaviour

subFunc()

"""#Python Generators
Python generators are a simple way of creating iterators. All the work we mentioned above are automatically handled by generators in Python. Simply speaking, a generator is a function that returns an object (iterator) which we can iterate over (one value at a time).
"""

def square(n):
  for i in range (n):
    yield i**2

for n in square(10):
  print(n)

"""#Built In Function - Next"""

def square():
  for i in range (n)
  yield i**2

a = square()

print(next(a))  #After Yielding all the values next() causes a StopIteration error